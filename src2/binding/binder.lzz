class Binder {
public:
	
	explicit Binder(sqlite3_stmt* _handle) {
		handle = _handle;
		error = NULL;
		param_count = sqlite3_bind_parameter_count(_handle);
		anon_index = 0;
	}
	
	~Binder() {
		delete[] error;
	}
	
	inline const char* GetError() {
		return error;
	}
	
	void Bind(NODE_ARGUMENTS info, int argc, Query* query) {
		assert(anon_index == 0);
		Result result = BindArgs(info, argc, query);
		if (!error && result.count != param_count) {
			if (result.count < param_count) {
				if (!result.bound_object && query->GetBindMap()->GetLength()) {
					SetError("Missing named parameters");
				} else {
					SetError("Too few parameter values were provided");
				}
			} else {
				SetError("Too many parameter values were provided");
			}
		}
	}
	
protected:
	struct Result {
		int count;
		bool bound_object;
	};
	
	static bool IsPlainObject(v8::Local<v8::Object> obj) {
		v8::Local<v8::Value> proto = obj->GetPrototype();
		v8::Local<v8::Context> ctx = obj->CreationContext();
		ctx->Enter();
		/*
			TODO:
			Check if this works when the isolate is retrieved before ctx->Enter().
			If so, also check that StrictEquals(Nan::Null()) works with v8::Null(isolate).
		 */
		EasyIsolate;
		v8::Local<v8::Value> baseProto = v8::Object::New(isolate)->GetPrototype();
		ctx->Exit();
		return proto->StrictEquals(baseProto) || proto->StrictEquals(Nan::Null());
	}
	
	void SetError(const char* message) {
		assert(error == NULL);
		assert(message != NULL);
		error = COPY(message);
	}
	
	virtual int NextAnonIndex() {
		while (sqlite3_bind_parameter_name(handle, ++anon_index) != NULL) {}
		return anon_index;
	}
	
	// Binds the value at the given index or sets an appropriate error message.
	void BindValue(v8::Local<v8::Value> value, int index) {
		int status = Data::BindValueFromJS(handle, index, value);
		if (status != SQLITE_OK) {
			switch (status) {
				case -1:
					return SetError("SQLite3 can only bind numbers, strings, Buffers, and null");
				case SQLITE_RANGE:
					return SetError("Too many parameter values were provided");
				case SQLITE_TOOBIG:
					return SetError("The bound string or Buffer is too big");
				case SQLITE_NOMEM:
					return SetError("Out of memory");
				default:
					return SetError("An unexpected error occured while trying to bind parameters");
			}
		}
		assert(false);
	}
	
	// Binds each value in the array or sets an appropriate error message.
	// The number of successfully bound parameters is returned.
	int BindArray(v8::Local<v8::Array> arr) {
		EasyIsolate;
		v8::Local<v8::Context> ctx = isolate->GetCurrentContext();
		unsigned int length = arr->Length();
		if (length > INT_MAX) {
			SetError("Too many parameter values were provided");
			return 0;
		}
		int len = static_cast<int>(length);
		for (int i=0; i<len; ++i) {
			v8::MaybeLocal<v8::Value> maybeValue = arr->Get(ctx, i);
			if (maybeValue.IsEmpty()) {
				SetError("");
				return i;
			}
			BindValue(maybeValue.ToLocalChecked(), NextAnonIndex());
			if (error) {
				return i;
			}
		}
		return len;
	}
	
	// Binds all named parameters using the values found in the given object.
	// The number of successfully bound parameters is returned.
	// If a named parameter is missing from the object, an error message is set.
	// This should only be invoked once per instance.
	virtual int BindObject(v8::Local<v8::Object> obj, BindMap* bind_map) {
		EasyIsolate;
		v8::Local<v8::Context> ctx = isolate->GetCurrentContext();
		BindMap::Pair* pairs = bind_map->GetPairs();
		int len = bind_map->GetLength();
		
		for (int i=0; i<len; ++i) {
			v8::Local<v8::String> key = pairs[i].GetName(isolate);
			
			// Check if the named parameter was provided.
			v8::Maybe<bool> has_property = obj->HasOwnProperty(ctx, key);
			if (has_property.IsNothing()) {
				SetError("");
				return i;
			}
			if (!has_property.FromJust()) {
				v8::String::Utf8Value param_name(key);
				CONCAT3(message, "Missing named parameter \"", *param_name, "\"");
				SetError(message.c_str());
				return i;
			}
			
			// Get the current property value.
			v8::MaybeLocal<v8::Value> maybeValue = obj->Get(ctx, key);
			if (maybeValue.IsEmpty()) {
				SetError("");
				return i;
			}
			
			BindValue(maybeValue.ToLocalChecked(), pairs[i].GetIndex());
			if (error) {
				return i;
			}
		}
		
		return len;
	}
	
	// Binds all parameters using the values found in the arguments object.
	// Anonymous parameter values can be directly in the arguments object or in an Array.
	// Named parameter values can be provided in a plain Object argument.
	// Only one plain Object argument may be provided.
	// If an error occurs, an appropriate error message is set.
	// The return value is a struct indicating how many parameters were successfully bound
	// and whether or not it tried to bind an object.
	Result BindArgs(NODE_ARGUMENTS info, int argc, Query* query) {
		int count = 0;
		bool bound_object = false;
		
		for (int i=0; i<argc; ++i) {
			v8::Local<v8::Value> arg = info[i];
			
			if (arg->IsArray()) {
				count += BindArray(v8::Local<v8::Array>::Cast(arg));
				if (error) break;
				continue;
			}
			
			if (arg->IsObject() && !node::Buffer::HasInstance(arg)) {
				v8::Local<v8::Object> obj = v8::Local<v8::Object>::Cast(arg);
				if (IsPlainObject(obj)) {
					if (bound_object) {
						SetError("You cannot specify named parameters in two different objects");
						break;
					}
					bound_object = true;
					
					count += BindObject(obj, query->GetBindMap());
					if (error) break;
					continue;
				}
			}
			
			BindValue(arg, NextAnonIndex());
			if (error) break;
			count += 1;
		}
		
		return Result {count, bound_object};
	}
	
	sqlite3_stmt* handle;
	const char* error; // This value should only be set by SetError()
	int param_count;
	int anon_index; // This value should only be used by NextAnonIndex()
};
