#define NODE_ARGUMENTS const Nan::FunctionCallbackInfo<v8::Value>&
#define NODE_METHOD(name) static void name(NODE_ARGUMENTS info)
#define NODE_GETTER(name) static void name(v8::Local<v8::String> _, const Nan::PropertyCallbackInfo<v8::Value>& info)
#define REGISTER(name) friend void RegisterModule(v8::Local<v8::Object> exports, v8::Local<v8::Object> module); static void name(v8::Local<v8::Object> exports)

#define EasyHandleScope v8::HandleScope scope(v8::Isolate::GetCurrent())
#define NewHandleScope v8::HandleScope scope(isolate)
#define EasyIsolate v8::Isolate* isolate = v8::Isolate::GetCurrent()
#define UseIsolate v8::Isolate* isolate = info.GetIsolate()
#define OnlyIsolate info.GetIsolate()
#define UseContext v8::Local<v8::Context> ctx = isolate->GetCurrentContext()
#define OnlyContext isolate->GetCurrentContext()

#define Unwrap Nan::ObjectWrap::Unwrap

inline v8::Local<v8::String> NEW_INTERNAL_STRING_FAST(const char* data) {
	return v8::String::NewFromOneByte(v8::Isolate::GetCurrent(), reinterpret_cast<const uint8_t*>(data), v8::NewStringType::kInternalized).ToLocalChecked();
}
inline v8::Local<v8::String> StringFromLatin1(v8::Isolate* isolate, const char* data, int length) {
	return v8::String::NewFromOneByte(isolate, reinterpret_cast<const uint8_t*>(data), v8::NewStringType::kNormal, length).ToLocalChecked();
}
inline v8::Local<v8::String> StringFromUtf8(v8::Isolate* isolate, const char* data, int length) {
	return v8::String::NewFromUtf8(isolate, data, v8::NewStringType::kNormal, length).ToLocalChecked();
}
inline v8::Local<v8::String> InternalizedFromUtf8(v8::Isolate* isolate, const char* data, int length) {
	return v8::String::NewFromUtf8(isolate, data, v8::NewStringType::kInternalized, length).ToLocalChecked();
}

template<ErrorFactory T> inline void ThrowException(const char* message) {
	EasyIsolate;
	isolate->ThrowException(T(StringFromUtf8(isolate, message, -1)));
}

#define ThrowError ThrowException<v8::Exception::Error>
#define ThrowTypeError ThrowException<v8::Exception::TypeError>
#define ThrowRangeError ThrowException<v8::Exception::RangeError>

#define _REQUIRE_ARGUMENT(at, var, Type, message, after)                       \
	if (info.Length() <= (at()) || !info[at()]->Is##Type())                    \
		return ThrowTypeError("Expected "#at" arguement to be "#message);      \
	var = v8::Local<v8::Type>::Cast(info[at()])after

#define REQUIRE_ARGUMENT_INT32(at, var)                                        \
	_REQUIRE_ARGUMENT(at, var, Int32, a 32-bit signed integer, ->Value())
#define REQUIRE_ARGUMENT_BOOLEAN(at, var)                                      \
	_REQUIRE_ARGUMENT(at, var, Boolean, a boolean, ->Value())
#define REQUIRE_ARGUMENT_STRING(at, var)                                       \
	_REQUIRE_ARGUMENT(at, var, String, a string,)
#define REQUIRE_ARGUMENT_ARRAY(at, var)                                        \
	_REQUIRE_ARGUMENT(at, var, Array, an array,)

#define REQUIRE_DATABASE_OPEN(db)                                              \
	if (!db->open)                                                             \
		return ThrowTypeError("The database connection is not open")
#define REQUIRE_DATABASE_NOT_BUSY(db)                                          \
	if (db->busy)                                                              \
		return ThrowTypeError("This database connection is busy executing a query")
#define REQUIRE_DATABASE_NOT_READONLY(db)                                      \
	if (db->readonly)                                                          \
		return ThrowTypeError("This operation is not available while in readonly mode")

#define first() 0
#define second() 1
#define third() 2
#define fourth() 3
#define fifth() 4
#define sixth() 5
#define seventh() 6
#define eighth() 7
#define ninth() 8
#define tenth() 9

// Copies a C-String into the heap and returns a pointer to it.
inline const char* COPY(const char* source) {
	size_t bytes = strlen(source) + 1;
	char* dest = new char[bytes];
	strlcpy(dest, source, bytes);
	return dest;
}

// Creates a stack-allocated std:string of the concatenation of 2 well-formed
// C-strings.
#define CONCAT2(result, a, b)                                                  \
	std::string result(a);                                                     \
	result += b

// Creates a stack-allocated std:string of the concatenation of 3 well-formed
// C-strings.
#define CONCAT3(result, a, b, c)                                               \
	std::string result(a);                                                     \
	result += b;                                                               \
	result += c

#define ALLOC_ARRAY(Type, count)                                               \
	static_cast<Type*>(::operator new[]((count) * sizeof(Type)))

#define FREE_ARRAY(array_pointer)                                              \
	::operator delete[](array_pointer)

class Functor { public:
	virtual ~Functor() {}
	virtual void Invoke(void* ctx) = 0;
};

#hdr
typedef v8::Local<v8::Value> (*ErrorFactory)(v8::Local<v8::String>);
template <class T> using Persistent = v8::Persistent<T, v8::CopyablePersistentTraits<T>>;
#end
