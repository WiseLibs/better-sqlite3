class Statement : public Nan::ObjectWrap, public Query {
public:
	
	static v8::MaybeLocal<v8::Object> New(v8::Isolate* isolate, v8::Local<v8::Object> database, v8::Local<v8::String> source) {
		v8::Local<v8::Function> c = v8::Local<v8::Function>::New(isolate, constructor);
		v8::Local<v8::Value> args[2] = { database, source };
		constructing_privileges = true;
		v8::MaybeLocal<v8::Object> maybe_statement = c->NewInstance(OnlyContext, 2, args);
		constructing_privileges = false;
		return maybe_statement;
	}
	
	BindMap* GetBindMap(v8::Isolate* isolate) {
		if (has_bind_map) return BindMapPointer();
		BindMap* bind_map = BindMapPointer();
		int param_count = sqlite3_bind_parameter_count(handle);
		for (int i=1; i<=param_count; ++i) {
			const char* name = sqlite3_bind_parameter_name(handle, i);
			if (name != NULL) bind_map->Add(isolate, name + 1, i);
		}
		has_bind_map = true;
		return bind_map;
	}
	
	void CloseHandles() {
		if (alive) {
			alive = false;
			if (bound) sqlite3_clear_bindings(handle);
			sqlite3_finalize(handle);
		}
	}
	
	~Statement() {
		if (alive) db->RemoveStatement(this);
		CloseHandles();
	}
	
private:
	explicit Statement(Database* _db, sqlite3_stmt* _handle, bool _safe_ints, bool _returns_data) : Nan::ObjectWrap(), Query(next_id++),
		db(_db),
		handle(_handle),
		alive(true),
		bound(false),
		has_bind_map(false),
		safe_ints_setting(_safe_ints),
		safe_ints(_safe_ints),
		pluck_setting(false),
		pluck(false),
		returns_data(_returns_data) {
		assert(db != NULL);
		assert(handle != NULL);
		assert(db->GetState()->open);
		assert(!db->GetState()->busy);
		db->AddStatement(this);
	}
	
	REGISTER(Init) {
		v8::Local<v8::FunctionTemplate> t = Nan::New<v8::FunctionTemplate>(JS_new);
		t->InstanceTemplate()->SetInternalFieldCount(1);
		t->SetClassName(NEW_INTERNAL_STRING_FAST("Statement"));
		
		Nan::SetPrototypeMethod(t, "run", JS_run);
		Nan::SetPrototypeMethod(t, "get", JS_get);
		Nan::SetPrototypeMethod(t, "all", JS_all);
		Nan::SetPrototypeMethod(t, "each", JS_each);
		Nan::SetPrototypeMethod(t, "bind", JS_bind);
		Nan::SetPrototypeMethod(t, "pluck", JS_pluck);
		Nan::SetPrototypeMethod(t, "safeIntegers", JS_safeIntegers);
		Nan::SetAccessor(t->InstanceTemplate(), NEW_INTERNAL_STRING_FAST("returnsData"), JS_returnsData);
		
		constructor.Reset(exports->GetIsolate(), Nan::GetFunction(t).ToLocalChecked());
		next_id = 0;
		constructing_privileges = false;
	}
	
	NODE_METHOD(JS_new) {
		if (!constructing_privileges) {
			return ThrowTypeError("Statements can only be constructed by the db.prepare() method");
		}
		REQUIRE_ARGUMENT_OBJECT(first, v8::Local<v8::Object> database);
		REQUIRE_ARGUMENT_STRING(second, v8::Local<v8::String> source);
		Database* db = Unwrap<Database>(database);
		REQUIRE_DATABASE_OPEN(db->GetState());
		REQUIRE_DATABASE_NOT_BUSY(db->GetState());
		
		v8::String::Value sql(source);
		const void* tail;
		sqlite3_stmt* handle;
		bool returns_data;
		
		if (sqlite3_prepare16_v2(db->GetHandle(), *sql, sql.length() * sizeof(uint16_t) + 1, &handle, &tail) != SQLITE_OK) {
			return db->ThrowDatabaseError();
		}
		if (handle == NULL) {
			return ThrowRangeError("The supplied SQL string contains no statements");
		}
		if (tail != (const void*)(*sql + sql.length())) {
			sqlite3_finalize(handle);
			return ThrowRangeError("The supplied SQL string contains more than one statement");
		}
		if (sqlite3_stmt_readonly(handle) && sqlite3_column_count(handle) >= 1) {
			returns_data = true;
		} else {
			REQUIRE_DATABASE_NOT_READONLY(db->GetState(), sqlite3_finalize(handle));
			returns_data = db->GetState()->pragma_mode;
		}
		
		UseIsolateAndContext;
		Statement* stmt = new Statement(db, handle, db->GetState()->safe_ints, returns_data);
		stmt->Wrap(info.This());
		SetFrozen(ctx, info.This(), "source", source);
		SetFrozen(ctx, info.This(), "database", database);
		
		info.GetReturnValue().Set(info.This());
	}
	
	NODE_METHOD(JS_run) {
		STATEMENT_START(info, info.Length(), REQUIRE_STATEMENT_DOESNT_RETURN_DATA);
		sqlite3* db_handle = db->GetHandle();
		int total_changes_before = sqlite3_total_changes(db_handle);
		
		sqlite3_step(handle);
		if (sqlite3_reset(handle) == SQLITE_OK) {
			int changes = sqlite3_total_changes(db_handle) == total_changes_before ? 0 : sqlite3_changes(db_handle);
			sqlite3_int64 id = sqlite3_last_insert_rowid(db_handle);
			UseIsolateAndContext;
			v8::Local<v8::Object> result = v8::Object::New(isolate);
			result->Set(ctx, NEW_INTERNAL_STRING_FAST("changes"), v8::Number::New(isolate, static_cast<double>(changes))).FromJust();
			result->Set(ctx, NEW_INTERNAL_STRING_FAST("lastInsertROWID"), Int64::NewProperInteger(isolate, id, stmt->safe_ints)).FromJust();
			QUERY_RETURN(stmt, STATEMENT_UNBIND, result);
		}
		QUERY_THROW(stmt, STATEMENT_UNBIND);
	}
	
	NODE_METHOD(JS_get) {
		STATEMENT_START(info, info.Length(), REQUIRE_STATEMENT_RETURNS_DATA);
		UseIsolate;
		int status = sqlite3_step(handle);
		if (status == SQLITE_ROW) {
			v8::Local<v8::Value> result = stmt->pluck
				? Data::GetValueJS(isolate, handle, 0, stmt->safe_ints)
				: Data::GetRowJS(isolate, OnlyContext, handle, stmt->safe_ints);
			sqlite3_reset(handle);
			QUERY_RETURN(stmt, STATEMENT_UNBIND, result);
		} else if (status == SQLITE_DONE) {
			sqlite3_reset(handle);
			QUERY_RETURN(stmt, STATEMENT_UNBIND, v8::Undefined(isolate));
		}
		sqlite3_reset(handle);
		QUERY_THROW(stmt, STATEMENT_UNBIND);
	}
	
	NODE_METHOD(JS_all) {
		STATEMENT_START(info, info.Length(), REQUIRE_STATEMENT_RETURNS_DATA);
		UseIsolateAndContext;
		v8::Local<v8::Array> result = v8::Array::New(isolate, 0);
		unsigned int row_count = 0;
		const bool safe_integers = stmt->safe_ints;
		
		if (stmt->pluck) {
			while (sqlite3_step(handle) == SQLITE_ROW) {
				result->Set(ctx, row_count++, Data::GetValueJS(isolate, handle, 0, safe_integers)).FromJust();
			}
		} else {
			while (sqlite3_step(handle) == SQLITE_ROW) {
				result->Set(ctx, row_count++, Data::GetRowJS(isolate, ctx, handle, safe_integers)).FromJust();
			}
		}
		
		if (sqlite3_reset(handle) == SQLITE_OK) {
			QUERY_RETURN(stmt, STATEMENT_UNBIND, result);
		}
		QUERY_THROW(stmt, STATEMENT_UNBIND);
	}
	
	NODE_METHOD(JS_each) {
		REQUIRE_LAST_ARGUMENT_FUNCTION(bind_args_count, callback);
		STATEMENT_START(info, info.Length(), REQUIRE_STATEMENT_RETURNS_DATA);
		UseIsolateAndContext;
		v8::Local<v8::Primitive> Null = v8::Null(isolate);
		const bool safe_integers = stmt->safe_ints;
		const bool pluck = stmt->pluck;
		bool js_error = false;
		
		db_state->busy = true;
		while (sqlite3_step(handle) == SQLITE_ROW) {
			NewHandleScope;
			v8::Local<v8::Value> arg = pluck
				? Data::GetValueJS(isolate, handle, 0, safe_integers)
				: Data::GetRowJS(isolate, ctx, handle, safe_integers);
			v8::MaybeLocal<v8::Value> callback_return_value = callback->Call(ctx, Null, 1, &arg);
			if (callback_return_value.IsEmpty()) {js_error = true; break;}
		}
		db_state->busy = false;
		
		if (sqlite3_reset(handle) == SQLITE_OK && !js_error) {
			QUERY_RETURN(stmt, STATEMENT_UNBIND, v8::Undefined(isolate));
		}
		if (js_error) db_state->was_js_error = true;
		QUERY_THROW(stmt, STATEMENT_UNBIND);
	}
	
	NODE_METHOD(JS_bind) {
		Statement* stmt = Unwrap<Statement>(info.This());
		if (stmt->bound) return ThrowTypeError("The bind() method can only be invoked once per statement object");
		REQUIRE_DATABASE_OPEN(stmt->db->GetState());
		REQUIRE_DATABASE_NOT_BUSY(stmt->db->GetState());
		sqlite3_stmt* handle = stmt->handle;
		Binder binder(handle);
		QUERY_BIND(stmt, info, info.Length(), STATEMENT_UNBIND);
		stmt->bound = true;
		info.GetReturnValue().Set(info.This());
	}
	
	NODE_METHOD(JS_pluck) {
		Statement* stmt = Unwrap<Statement>(info.This());
		if (!stmt->returns_data) return ThrowTypeError("The pluck() method is only for statements that return data");
		REQUIRE_DATABASE_NOT_BUSY(stmt->db->GetState());
		// TODO
		stmt->pluck = info.Length() == 0 || info[0]->BooleanValue() == true;
		info.GetReturnValue().Set(info.This());
	}
	
	NODE_METHOD(JS_safeIntegers) {
		Statement* stmt = Unwrap<Statement>(info.This());
		REQUIRE_DATABASE_NOT_BUSY(stmt->db->GetState());
		// TODO
		stmt->safe_ints = info.Length() == 0 || info[0]->BooleanValue() == true;
		info.GetReturnValue().Set(info.This());
	}
	
	NODE_GETTER(JS_returnsData) {
		info.GetReturnValue().Set(Unwrap<Statement>(info.This())->returns_data);
	}
	
	static v8::Persistent<v8::Function> constructor;
	static sqlite3_uint64 next_id;
	static bool constructing_privileges;
	
	Database* const db;
	sqlite3_stmt* const handle;
	bool alive;
	bool bound;
	bool has_bind_map;
	bool safe_ints_setting;
	bool safe_ints;
	bool pluck_setting;
	bool pluck;
	const bool returns_data;
};
