class Statement;
class Transaction;
class Database : public Nan::ObjectWrap {
private:
	
	explicit Database(DatabaseHandles* handles, bool _readonly) : Nan::ObjectWrap(),
		db_handle(handles->db_handle),
		extras(new DatabaseExtras(handles)),
		open(true),
		busy(false),
		pragma_mode(false),
		safe_ints(false),
		was_js_error(false),
		readonly(_readonly) {
		assert(handles->error == NULL);
	}
	
	~Database() {
		CloseHandles();
		delete extras;
	}
	
	class DatabaseExtras { friend class Database;
		explicit DatabaseExtras(DatabaseHandles* handles)
			: stmts(), transs(), begin(handles->begin), commit(handles->commit), rollback(handles->rollback) {
			assert(handles->error == NULL);
		}
		std::set<Statement*, Query::Compare> stmts;
		std::set<Transaction*, Query::Compare> transs;
		sqlite3_stmt* const begin;
		sqlite3_stmt* const commit;
		sqlite3_stmt* const rollback;
	};
	
	REGISTER(Init) {
		v8::Local<v8::FunctionTemplate> t = Nan::New<v8::FunctionTemplate>(JS_new);
		t->InstanceTemplate()->SetInternalFieldCount(1);
		t->SetClassName(NEW_INTERNAL_STRING_FAST("Database"));
		
		Nan::SetPrototypeMethod(t, "prepare", JS_prepare);
		Nan::SetPrototypeMethod(t, "transaction", JS_transaction);
		Nan::SetPrototypeMethod(t, "exec", JS_exec);
		Nan::SetPrototypeMethod(t, "pragma", JS_pragma);
		Nan::SetPrototypeMethod(t, "checkpoint", JS_checkpoint);
		Nan::SetPrototypeMethod(t, "register", JS_register);
		Nan::SetPrototypeMethod(t, "close", JS_close);
		Nan::SetPrototypeMethod(t, "defaultSafeIntegers", JS_defaultSafeIntegers);
		Nan::SetAccessor(t->InstanceTemplate(), NEW_INTERNAL_STRING_FAST("open"), JS_open);
		
		Nan::Set(exports, NEW_INTERNAL_STRING_FAST("Database"), Nan::GetFunction(t).ToLocalChecked());
	}
	
	NODE_METHOD(JS_new) {
		REQUIRE_ARGUMENT_STRING(first, v8::Local<v8::String> filename);
		REQUIRE_ARGUMENT_STRING(second, v8::Local<v8::String> filenameGiven);
		REQUIRE_ARGUMENT_BOOLEAN(third, bool in_memory);
		REQUIRE_ARGUMENT_BOOLEAN(fourth, bool readonly);
		UseIsolate;
		UseContext;
		
		DatabaseHandles handles(filename);
		if (handles.error) {
			std::string message = CONCAT("SQLite: ", handles.error);
			return ThrowError(message.c_str());
		}
		
		assert(sqlite3_db_mutex(handles.db_handle) == NULL);
		sqlite3_busy_timeout(handles.db_handle, 5000);
		sqlite3_limit(handles.db_handle, SQLITE_LIMIT_LENGTH, MAX_BUFFER_SIZE < MAX_STRING_SIZE ? MAX_BUFFER_SIZE : MAX_STRING_SIZE);
		sqlite3_limit(handles.db_handle, SQLITE_LIMIT_SQL_LENGTH, MAX_STRING_SIZE);
		sqlite3_limit(handles.db_handle, SQLITE_LIMIT_COLUMN, INT_MAX);
		sqlite3_limit(handles.db_handle, SQLITE_LIMIT_COMPOUND_SELECT, INT_MAX);
		sqlite3_limit(handles.db_handle, SQLITE_LIMIT_VARIABLE_NUMBER, BindMap::PARAMETER_MASK);
		
		Database* db = new Database(&handles, readonly);
		db->Wrap(info.This());
		SetFrozen(ctx, info.This(), "memory", in_memory ? v8::True(isolate) : v8::False(isolate));
		SetFrozen(ctx, info.This(), "readonly", readonly ? v8::True(isolate) : v8::False(isolate));
		SetFrozen(ctx, info.This(), "name", filenameGiven);
		
		info.GetReturnValue().Set(info.This());
	}
	
	NODE_METHOD(JS_prepare) {
		REQUIRE_ARGUMENT_STRING(first, v8::Local<v8::String> source);
		v8::MaybeLocal<v8::Object> maybe_statement = Statement::New(Unwrap<Database>(info.This()), OnlyIsolate, source);
		if (!maybe_statement.IsEmpty()) {
			info.GetReturnValue().Set(maybe_statement.ToLocalChecked());
		}
	}
	
	NODE_METHOD(JS_transaction) {
		REQUIRE_ARGUMENT_ARRAY(first, v8::Local<v8::Array> sources);
		v8::MaybeLocal<v8::Object> maybe_transaction = Transaction::New(Unwrap<Database>(info.This()), OnlyIsolate, sources);
		if (!maybe_transaction.IsEmpty()) {
			info.GetReturnValue().Set(maybe_transaction.ToLocalChecked());
		}
	}
	
	NODE_METHOD(JS_exec) {
		Database* db = Unwrap<Database>(info.This());
		REQUIRE_ARGUMENT_STRING(first, v8::Local<v8::String> source);
		REQUIRE_DATABASE_OPEN(db);
		REQUIRE_DATABASE_NOT_BUSY(db);
		REQUIRE_DATABASE_NOT_READONLY(db);
		
		v8::String::Utf8Value sql(source);
		char* err;
		
		sqlite3_exec(db->db_handle, *sql, NULL, NULL, &err);
		if (err != NULL) {
			db->ThrowDatabaseError(err);
			return sqlite3_free(err);
		}
		
		info.GetReturnValue().Set(info.This());
	}
	
	NODE_METHOD(JS_pragma) {
		REQUIRE_ARGUMENT_BOOLEAN(first, Unwrap<Database>(info.This())->pragma_mode);
	}
	
	NODE_METHOD(JS_checkpoint) {
		Database* db = Unwrap<Database>(info.This());
		REQUIRE_ARGUMENT_STRING(first, v8::Local<v8::String> onlyDatabase);
		REQUIRE_ARGUMENT_BOOLEAN(second, bool force);
		REQUIRE_DATABASE_OPEN(db);
		REQUIRE_DATABASE_NOT_BUSY(db);
		REQUIRE_DATABASE_NOT_READONLY(db);
		static auto get_ratio = [](int tf, int cf) {
			return (cf < 0 || tf <= 0) ? 1.0 : (static_cast<double>(cf) / static_cast<double>(tf));
		};
		
		v8::String::Utf8Value only_database(onlyDatabase);
		int mode = force ? SQLITE_CHECKPOINT_RESTART : SQLITE_CHECKPOINT_PASSIVE;
		int total_frames;
		int checkpointed_frames;
		
		if (only_database.length() != 0) {
			int status = sqlite3_wal_checkpoint_v2(db->db_handle, *only_database, mode, &total_frames, &checkpointed_frames);
			if (status == SQLITE_OK) return info.GetReturnValue().Set(get_ratio(total_frames, checkpointed_frames));
			if (status == SQLITE_BUSY) return info.GetReturnValue().Set(0.0);
			return db->ThrowDatabaseError();
		}
		
		sqlite3_stmt* st_handle;
		if (sqlite3_prepare_v2(db->db_handle, "PRAGMA database_list", -1, &st_handle, NULL) != SQLITE_OK) {
			return db->ThrowDatabaseError();
		}
		std::vector<std::string> database_names;
		while (sqlite3_step(st_handle) == SQLITE_ROW) {
			database_names.emplace_back(reinterpret_cast<const char*>(sqlite3_column_text(st_handle, 1)), sqlite3_column_bytes(st_handle, 1));
		}
		if (sqlite3_finalize(st_handle) != SQLITE_OK) {
			return db->ThrowDatabaseError();
		}
		
		UseIsolate;
		UseContext;
		v8::Local<v8::Object> result = v8::Object::New(isolate);
		for (std::string const &name : database_names) {
			int status = sqlite3_wal_checkpoint_v2(db->db_handle, name.c_str(), mode, &total_frames, &checkpointed_frames);
			if (status == SQLITE_OK) {
				result->Set(ctx, InternalizedFromUtf8(isolate, name.c_str(), name.length()), v8::Number::New(isolate, get_ratio(total_frames, checkpointed_frames))).FromJust();
			} else if (status == SQLITE_BUSY) {
				result->Set(ctx, InternalizedFromUtf8(isolate, name.c_str(), name.length()), v8::Number::New(isolate, 0.0)).FromJust();
			} else {
				return db->ThrowDatabaseError();
			}
		}
		info.GetReturnValue().Set(result);
	}
	
	NODE_METHOD(JS_register); // TODO
	
	NODE_METHOD(JS_close) {
		Database* db = Unwrap<Database>(info.This());
		if (db->open) {
			REQUIRE_DATABASE_NOT_BUSY(db);
			db->CloseHandles();
		}
		info.GetReturnValue().Set(info.This());
	}
	
	NODE_METHOD(JS_defaultSafeIntegers) {
		REQUIRE_ARGUMENT_BOOLEAN(first, Unwrap<Database>(info.This())->safe_ints);
		info.GetReturnValue().Set(info.This());
	}
	
	NODE_GETTER(JS_open) {
		info.GetReturnValue().Set(Unwrap<Database>(info.This())->open);
	}
	
	void CloseHandles() {
		if (open) {
			open = false;
			for (Statement* stmt : extras->stmts) {stmt->CloseHandles();}
			for (Transaction* trans : extras->transs) {trans->CloseHandles();}
			extras->stmts.clear();
			extras->transs.clear();
			sqlite3_finalize(extras->begin);
			sqlite3_finalize(extras->commit);
			sqlite3_finalize(extras->rollback);
			int status = sqlite3_close(db_handle);
			assert(status == SQLITE_OK);
		}
	}
	
	void ThrowDatabaseError(const char* err = NULL) {
		if (was_js_error) {
			assert(err == NULL);
			was_js_error = false;
		} else {
			if (err == NULL) {
				err = sqlite3_errmsg(db_handle);
			}
			std::string message = CONCAT("SQLite: ", err);
			ThrowError(message.c_str());
		}
	}
	
	static const int MAX_BUFFER_SIZE = node::Buffer::kMaxLength > INT_MAX ? INT_MAX : static_cast<int>(node::Buffer::kMaxLength);
	static const int MAX_STRING_SIZE = v8::String::kMaxLength > INT_MAX ? INT_MAX : static_cast<int>(v8::String::kMaxLength);
	
	sqlite3* const db_handle;
	DatabaseExtras* const extras;
	bool open;
	bool busy;
	bool pragma_mode;
	bool safe_ints;
	bool was_js_error;
	const bool readonly;
};
