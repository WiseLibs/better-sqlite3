in c++:

Two JavaScript APIs:
- begin()
This returns a Transaction object. You can use .and() to append statements into the transaction. These statements may be read-only, or not. When finished adding statements, you must use .end() or .commit(), after which the transaction can be .run() (possibly multiple times). The .run() method returns a promise, which resolves with an object describing the changes, or rejects with an Error.
- prepare(string source, [Array boundValues])
This returns a Statement object. It can only consist of the single SQL statement that is passed upon construction. Depending on whether the statement is read-only, a different API is used for executing the statement (possibly many times). If boundValues are given, they are permanently bound to the statement, and attempting to bind values via .get(), .all(), .each()/.forEach(), or .run(), will throw an Error.
	- readonly === true
		The .get(bv), .all(bv), and .each(bv, cb)/.forEach(bv, cb) methods can be used. The first two return promises which are resolved with values, or rejected with Errors. The third accepts a callback which is invoked for each result row, but also returns a promise which is resolved with undefined when all callbacks have returned, or rejects with an Error (no callbacks should be called in this case, if possible?). Each of these methods accepts an optional array argument bv, which are the values to bind to the statement for this execution.
	- readonly === false
		The .run(bv) method can be used, which returns a promise that is either resolved with an object describing the changes, or rejected with an Error. This method accepts an optional array argument bv, which are the values to bind to the statement for this execution.


assure that shared cache and in-memory databases work properly


use mutexes where appropriate


settings pragmas will currently only affect the writeHandle connection; there should be an API for this


remember to do db->Ref() and stmt->Ref() on every async operation, to protect from garbage collection



startTransaction() API does:
is the active_tranaction flag set? -> push to the db connection's transaction queue
otherwise -> set active_tranaction flag to 1, and exec "BEGIN;"



endTransaction() API does:
-> set active_tranaction flag to 2, and exec "COMMIT;"
-> flush up to, but not including, the next transaction



when statement is about to be executed:
is the active_tranaction flag 0 or 1? -> execute it
otherwise -> push it to the transaction queue, which is associated with the database connection



on commit hook AND on rollback hook:
if there is something in the db connection's queue -> flush up to, and including, the next transaction
otherwise -> set active_tranaction flag to 0



optionally enable, together:
PRAGMA journal_mode = WAL;
PRAGMA synchronous = 1;



---------- Automatic Atomic Transactions ----------
on commit hook, check for error, and if there was an error, return 1
the commit will then be converted into a rollback


---------- Package ----------
deal with ./test/ and .travis.yml


---------- Executable ----------
all tables should have INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL

in order for foreign keys to be unconditionally enforced, the child column must have NOT NULL

null values count as unique from eachother for UNIQUE constraints (and basically everything else)

DEFAULT applies when no value is specified for an INSERT. Explicitly given nulls do not trigger DEFAULT

foreign key REFERENCES <table> can be followed by ON DELETE and/or ON UPDATE:
SET NULL = when the parent's column is updated or deleted, the child's column becomes null
           (this still causes a violation if the child has NOT NULL)
SET DEFAULT = when the parent's column is updated or deleted, the child's column becomes the DEFAULT
              (this still causes a violation if the DEFAULT does not correspond with an actual parent)
CASCADE = when the parent row is deleted, the child row is deleted
          (for updates, the value propogates to all children)

ALTER TABLE actions

DROP TABLE actions
